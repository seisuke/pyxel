use anyhow::Result;
use pyxel_wrapper_ts_types::TsModule;
use std::env;
use std::fs;
use std::path::PathBuf;

use crate::generate_wrapper_rust::generate_wrapper_rust;

pub fn generate() -> Result<()> {
    let project_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let pkg_dir = project_dir.join("pkg");
    fs::create_dir_all(&pkg_dir)?; // 念のため pkg ディレクトリを作成
    let src_dir = project_dir.join("src");
    let json_path = project_dir
        .parent()
        .unwrap()
        .join("pyxel-wrapper-ts/pkg/tsbind_types.json");
    let dts_path = pkg_dir.join("pyxel_wrapper_ts.d.ts");
    let rust_path = src_dir.join("generated.rs");
    let ts_path = pkg_dir.join("pyxel.ts");
    let exported_path = pkg_dir.join("EXPORTED_FUNCTIONS.txt");
    let modules: Vec<TsModule> = if json_path.exists() {
        let data = fs::read_to_string(&json_path)?;
        serde_json::from_str(&data)?
    } else {
        vec![]
    };
    let exported_names = collect_exported_function_names(&modules);

    println!(
        "Generating bindings from:\n{}",
        serde_json::to_string_pretty(&modules)?
    );

    fs::write(&dts_path, generate_dts(&modules))?;
    fs::write(&rust_path, generate_wrapper_rust(&modules))?;
    fs::write(&ts_path, generate_pyxel_ts(&modules))?;
    fs::write(&exported_path, serde_json::to_string(&exported_names)?)?;

    println!(
        "✅ Generated: {:?},{:?},{:?},{:?}",
        dts_path, rust_path, ts_path, exported_path
    );

    Ok(())
}

fn rust_to_ts_type(rust_type: &str, self_type: Option<&str>) -> String {
    match rust_type {
        "i8" | "i16" | "i32" | "u8" | "u16" | "u32" | "f32" | "f64" => "number".to_string(),
        "bool" => "boolean".to_string(),
        "String" | "&str" => "string".to_string(),
        "void" => "void".to_string(),
        "Self" => self_type
            .map(|s| s.to_string())
            .unwrap_or_else(|| "any".to_string()),
        _ => "any".to_string(),
    }
}

fn generate_dts(modules: &[TsModule]) -> String {
    let mut lines = Vec::new();
    for m in modules {
        lines.push(format!("declare module \"{}\" {{", m.name));
        lines.push("  export const pyxel: {".to_string());

        for func in &m.functions {
            let func_string =
                format_ts_function(&func.name, &func.args, &func.return_type, None, 4);
            lines.push(func_string);
        }

        for class in &m.classes {
            lines.push(format!("    {}: {{", class.name));
            let constructor_args = &class.methods.iter().find(|m| m.name == "new").unwrap().args;
            let constructor_args_str = constructor_args
                .iter()
                .map(|(n, t)| format!("{}: {}", n, rust_to_ts_type(t, None)))
                .collect::<Vec<_>>()
                .join(", ");
            lines.push(format!("      new({}): {{", constructor_args_str));

            for method in &class.methods {
                if method.name != "new" {
                    let method_string = format_ts_function(
                        &method.name,
                        &method.args,
                        &method.return_type,
                        Some(&class.name),
                        8,
                    );
                    lines.push(method_string);
                }
            }
            lines.push("      };".to_string());
            lines.push("    };".to_string());
        }

        lines.push("  };".to_string());
        lines.push("}".to_string());
    }
    lines.join("\n")
}

fn format_ts_function(
    name: &str,
    args: &[(String, String)],
    return_type: &str,
    self_type: Option<&str>,
    indent: usize,
) -> String {
    let args_str = args
        .iter()
        .map(|(arg_name, arg_type)| {
            format!("{}: {}", arg_name, rust_to_ts_type(arg_type, self_type))
        })
        .collect::<Vec<_>>()
        .join(", ");

    format!(
        "{:indent$}{}({}): {};",
        "",
        name,
        args_str,
        rust_to_ts_type(return_type, self_type),
        indent = indent,
    )
}

fn generate_pyxel_ts(modules: &[TsModule]) -> String {
    let mut lines = Vec::new();

    lines.push(
        r#"/// <reference types="./pyxel_wrapper_ts" />
// Auto-generated by pyxel-wrapper-ts-bindgen
import { instancePromise } from './instance.js';

let instance: WebAssembly.Exports;
const ready = instancePromise.then((inst: { exports: WebAssembly.Exports }) => {
  instance = inst.exports;
});

"#
        .to_string(),
    );

    for module in modules {
        for class in &module.classes {
            lines.push(format!("class {} {{", class.name));
            let constructor_args = &class.methods.iter().find(|m| m.name == "new").unwrap().args;
            let constructor_body = constructor_args
                .iter()
                .map(|(n, t)| format!("public {}Value: {}", n, rust_to_ts_type(t, None)))
                .collect::<Vec<_>>()
                .join(", ");
            lines.push(format!("  constructor({}) {{}}", constructor_body));
            for method in &class.methods {
                if method.name != "new" {
                    lines.push(format!(
                        "  {}(): {} {{",
                        method.name,
                        rust_to_ts_type(&method.return_type, Some(&class.name))
                    ));
                    lines.push(format!("    return this.{}Value;", method.name));
                    lines.push("  }".to_string());
                }
            }
            lines.push("}".to_string());
            lines.push("".to_string());
        }

        lines.push("export const pyxel: typeof import(\"pyxel\").pyxel = {".to_string());
        for func in &module.functions {
            let args_str = func
                .args
                .iter()
                .map(|(n, t)| format!("{}: {}", n, rust_to_ts_type(t, None)))
                .collect::<Vec<_>>()
                .join(", ");
            let call_args = func
                .args
                .iter()
                .map(|(n, _)| n.clone())
                .collect::<Vec<_>>()
                .join(", ");
            lines.push(format!("  {}({}) {{", func.name, args_str));
            lines.push(format!(
                "    return (instance as any)._{}({});",
                func.name, call_args
            ));
            lines.push("  },".to_string());
        }
        for class in &module.classes {
            lines.push(format!("  {},", class.name));
        }
        lines.push("};".to_string());
        lines.push("export { ready };".to_string());
    }

    lines.join("\n")
}

fn collect_exported_function_names(modules: &[TsModule]) -> Vec<String> {
    let mut names = Vec::new();

    for m in modules {
        for func in &m.functions {
            names.push(format!("_{}", func.name));
        }

        for class in &m.classes {
            for method in &class.methods {
                let symbol_name = if method.name == "new" {
                    format!("_{}_new", class.name)
                } else {
                    format!("_{}_{}", class.name, method.name)
                };
                names.push(symbol_name);
            }
        }
    }

    names
}
