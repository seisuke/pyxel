use anyhow::Result;
use pyxel_wrapper_ts_types::TsModule;
use std::env;
use std::fs;
use std::path::PathBuf;

use crate::generate_wrapper_rust::generate_wrapper_rust;

pub fn generate() -> Result<()> {
    let project_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let pkg_dir = project_dir.join("pkg");
    fs::create_dir_all(&pkg_dir)?; // 念のため pkg ディレクトリを作成
    let src_dir = project_dir.join("src");
    let json_path = project_dir
        .parent()
        .unwrap()
        .join("pyxel-wrapper-ts/pkg/tsbind_types.json");
    let dts_path = pkg_dir.join("pyxel_wrapper_ts.d.ts");
    let rust_path = src_dir.join("generated.rs");
    let ts_path = pkg_dir.join("pyxel.ts");
    let modules: Vec<TsModule> = if json_path.exists() {
        let data = fs::read_to_string(&json_path)?;
        serde_json::from_str(&data)?
    } else {
        vec![]
    };

    println!(
        "Generating bindings from:\n{}",
        serde_json::to_string_pretty(&modules)?
    );

    fs::write(&dts_path, generate_dts(&modules))?;
    fs::write(&rust_path, generate_wrapper_rust(&modules))?;
    fs::write(&ts_path, generate_pyxel_ts(&modules))?;

    println!("✅ Generated: {:?} and {:?}", dts_path, rust_path);

    Ok(())
}

fn rust_to_ts_type(rust_type: &str, self_type: Option<&str>) -> String {
    match rust_type {
        "i8" | "i16" | "i32" | "u8" | "u16" | "u32" | "f32" | "f64" => "number".to_string(),
        "bool" => "boolean".to_string(),
        "String" | "&str" => "string".to_string(),
        "void" => "void".to_string(),
        "Self" => self_type
            .map(|s| s.to_string())
            .unwrap_or_else(|| "any".to_string()),
        _ => "any".to_string(),
    }
}

fn generate_dts(modules: &[TsModule]) -> String {
    let mut lines = Vec::new();
    for m in modules {
        lines.push(format!("declare module \"{}\" {{", m.name));
        for func in &m.functions {
            let func_string =
                format_ts_function(&func.name, &func.args, &func.return_type, None, 2, true);
            lines.push(func_string);
        }
        for class in &m.classes {
            lines.push(format!("  export class {} {{", class.name));
            for method in &class.methods {
                let method_string = format_ts_function(
                    &method.name,
                    &method.args,
                    &method.return_type,
                    Some(&class.name),
                    4,
                    false,
                );
                lines.push(method_string);
            }
            lines.push("  }".to_string());
        }
        lines.push("}".to_string());
    }
    lines.join("\n")
}

fn format_ts_function(
    name: &str,
    args: &[(String, String)],
    return_type: &str,
    self_type: Option<&str>,
    indent: usize,
    is_export: bool,
) -> String {
    let args_str = args
        .iter()
        .map(|(arg_name, arg_type)| {
            format!("{}: {}", arg_name, rust_to_ts_type(arg_type, self_type))
        })
        .collect::<Vec<_>>()
        .join(", ");

    let export_prefix = if is_export { "export function " } else { "" };
    format!(
        "{:indent$}{}{}({}): {};",
        "",
        export_prefix,
        name,
        args_str,
        rust_to_ts_type(return_type, self_type),
        indent = indent,
    )
}

fn generate_pyxel_ts(modules: &[TsModule]) -> String {
    let mut lines = Vec::new();

    lines.push(
        r#"// Auto-generated by pyxel-wrapper-ts-bindgen
import { instancePromise } from './instance.js';

let instance;
const ready = instancePromise.then((inst) => {
  instance = inst.exports;
});

"#
        .to_string(),
    );

    for module in modules {
        for function in &module.functions {
            lines.push(format!(
                "export function {}({}): {} {{",
                function.name,
                function
                    .args
                    .iter()
                    .map(|(name, ty)| format!("{}: {}", name, rust_to_ts_type(ty, None)))
                    .collect::<Vec<_>>()
                    .join(", "),
                rust_to_ts_type(&function.return_type, None),
            ));
            lines.push(format!(
                "  return (instance as any).{}({});",
                function.name,
                function
                    .args
                    .iter()
                    .map(|(name, _ty)| name.clone())
                    .collect::<Vec<_>>()
                    .join(", "),
            ));
            lines.push("}".to_string());
            lines.push("".to_string());
        }
    }

    lines.push("export { ready };".to_string());
    lines.join("\n")
}
